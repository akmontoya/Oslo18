

* MEMORE for SAS Version 1.1;
* Copyright 2016;
* by Amanda K. Montoya and Andrew F Hayes;
* www.afhayes.com;

* Permission is hereby granted, free of charge, to any person obtaining a copy of this software;
* and associated documentation files (the "Software"), to use the software in this form.  Distribution;
* after modification is prohibited, as is its use for any commercial purpose without authorization;  
* This software should not be posted or stored on any webpage, server, or directory accessible to;
* the public whether free or for a charge unless written permission has been granted by the copyright;
* holder.  The copyright holder requests that this software be distributed by directing users to;
* afhayes.com where the latest release of the software and related documentation is archived and;
* can be downloaded;

* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, ;
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ;
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT ;
* IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ;
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT ;
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE ;
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE ;

* The above text should be included in any distribution of the software;


%macro cdfinvt (p=,df=);
p0=-.322232431088;p1=-1;p2=-.342242088547;p3=-.0204231210245;p4=-.0000453642210148;
q0=.0993484626060;q1=.588581570495;q2=.531103462366;q3=.103537752850;q4=.0038560700634;
ppv=&p;if (&p > .5) then;do;ppv=1-&p;end;
y5=sqrt(-2*log(ppv));
xp=y5+((((y5*p4+p3)*y5+p2)*y5+p1)*y5+p0)/((((y5*q4+q3)*y5+q2)*y5+q1)*y5+q0);
if (&p <= .5) then;do;xp=-xp;end;
toutput=sqrt(&df*(exp((&df-(5/6))*(xp##2)/(&df-(2/3)+.11/&df)##2)-1));
%mend;

%macro memore (data=,y=,m=,conf=95,mc=0,samples=5000,normal=0,bc=0,decimals=10.4,
  save=xxx,seed=0,contrast=0,serial=0);
options pagesize=32767;
proc iml;
runnotes=j(14,1,0);
criterr=0;
use &data;
read all var{&m &y} into data;
ynames={&y};mnames={&m};names={&m &y};
ninit=nrow(data);
xx=(data = .);xx=xx[,+];
j=1;do i=1 to nrow(data);if xx[i,1]=0 then;do;data[j,]=data[i,];j=j+1;end;end;
data=data[1:j-1,];
mc = (&mc = 1);serial = (&serial = 1);
missing=ninit-nrow(data);
if (missing > 0) then;do;runnotes[1,1]=1;end;
if (ncol(ynames) ^= 2) then;do;runnotes[2,1]=2;criterr=1;end;
mcount=ncol(mnames);
if ("&save" = "") then saveboot="xxx";else saveboot="&save";
if (((mcount < 2) | ((mcount/2) ^= floor(mcount/2)) | (mcount > 20)) & (criterr ^= 2)) then;do;
  runnotes[6,1]=6;criterr=1;
end;

if (criterr = 0) then;do;
  do i = 1 to mcount;
    if ((mnames[1,i]=ynames[1,1]) | (mnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
      runnotes[8,1]=8;criterr=1;
    end;
  end;
end;

if ((serial=1) & (mc=1)) then;do;
  runnotes[12,1]=12;mc=0;
end;


zero=j(nrow(data),1,0);
do i = 1 to (ncol(data)-1) by 2;
  diff=data[,i]-data[,(i+1)];
  copy=(diff=zero);copy=copy[+];
  if (copy=nrow(data)) then;do;
    copyname=names[1,i]||names[1,(i+1)];
	runnotes[7,1]=7;criterr=1;
  end;
end;


if (&samples = 0) then;do;
  samples=5000;mc=1;
end;
if (&samples ^=0) then;do;
  samples=abs(floor(&samples))*(abs(floor(&samples))>=1000)+5000*(abs(floor(&samples))<1000);
end;
if (samples ^= &samples) then;do;
  runnotes[3,1]=3;
end;


conf=&conf;if ((&conf < 50) | (&conf > 99.99)) then;do;conf=95;runnotes[5,1]=5;end;

bc=floor(&bc);if ((mc=1) & (bc=1)) then;do;runnotes[9,1]=9;bc=0;end;
if ((&contrast=1) & ((mcount/2)=1)) then;do;runnotes[10,1]=10;end;
if ((serial = 1) & (mcount ^= 4)) then;do;runnotes[13,1]=13;criterr=1;end;

savboot=0;
  if ((saveboot ^= "xxx") & (samples > 0)) then;do;savboot=1;
end;

if (criterr=0) then;do; *1;
  mpairs=mcount/2;
  mnamemat=shape(mnames,mpairs,2);
  n=nrow(data);
  transmat={1 0.5, -1 0.5};
  tmat=j(ncol(data),ncol(data),0);
  do i = 1 to (2*mpairs+1) by 2;
    tmat[i:(i+1),i:(i+1)]=transmat;
  end;
  datat=data*tmat;
  aresmat=j(mpairs,7,0);
  ghostdes=j(n,1,1);
  alpha=(1-.01*conf);
  temp=alpha/2;
  %cdfinvt (p=temp,df=(n-1));
  tcrita=toutput;
  tcritc=toutput;
  
  do j=1 to mpairs;
    summean=datat[,(2*j)];summean=summean[+,]/n;
    datat[,(2*j)]=(datat[,(2*j)]-summean);
	apath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,(2*j-1)];
	tempmn=datat[,(2*j-1)];tempmn=tempmn[+,]/n;
	tempsm=datat[,(2*j-1)]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
	semdiff=sqrt(tempsm/n);
    tapath=apath/semdiff;
	dfapath=n-1;
	papath=2*(1-probt(abs(tapath),dfapath));
	lcia=apath-tcrita*semdiff;
	ucia=apath+tcrita*semdiff;
	aresmat[j,]=apath||semdiff||tapath||dfapath||papath||lcia||ucia;
  end;

  cpath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,(2*mpairs+1)];
  tempmn=datat[,(2*mpairs+1)];tempmn=tempmn[+,]/n;
  tempsm=datat[,(2*mpairs+1)]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
  seydiff=sqrt(tempsm/n);
  tcpath=cpath/seydiff;
  dfcpath=n-1;
  pcpath=2*(1-probt(abs(tcpath),dfcpath));
  lcic=cpath-tcritc*seydiff;
  ucic=cpath+tcritc*seydiff;
  cresmat=cpath||seydiff||tcpath||dfcpath||pcpath||lcic||ucic;

  if (serial=1) then;do;
    serres=j(3,7,0);
	serdes=j(n,1,1);serdes=serdes||dataT[,1:(ncol(dataT)-4)];
	M2modbs=inv(serdes`*serdes)*serdes`*dataT[,(ncol(dataT)-3)];
	M2pred=serdes*M2modbs;
    M2ssr=(datat[,(ncol(datat)-3)]-M2pred)##2;M2ssr=M2ssr[+,];
    tempmn=datat[,(ncol(datat)-3)];tempmn=tempmn[+,]/n;
    M2sst=(datat[,(ncol(datat)-3)]-tempmn)##2;M2sst=M2sst[+,];    
	M2Rsq=1-(M2ssr/m2sst);
	m2r=sqrt(M2Rsq);
    M2msr=M2ssr/(N-ncol(serdes));
	M2df1=ncol(serdes)-1;
	M2df2=(N-ncol(serdes));
	M2F=(m2df2*m2rsq)/(m2df1*(1-m2rsq));
    M2p=1-probf(M2F,M2df1,M2df2);
    sem2bmat=(m2msr*inv(serdes`*serdes));
	sem2b=sqrt(vecdiag(sem2bmat));
    m2modsum=M2r||m2rsq||m2msr||m2F||m2df1||m2df2||m2p;
    %cdfinvt (p=temp,df=m2df2);
    sercritt=toutput;
	serres[1:3,1]=m2modbs;
	serres[1:3,2]=sem2b;
	serres[1:3,3]=serres[1:3,1]/serres[1:3,2];
    serres[1:3,4]=j(3,1,m2df2);
	serres[1:3,5]=2*(1-probt(abs(serres[1:3,3]),m2df2));
	serres[1:3,6]=serres[1:3,1]-sercritt*serres[1:3,2];
	serres[1:3,7]=serres[1:3,1]+sercritt*serres[1:3,2];
	aresmat[2,]=serres[1,];
  end;

  bcpdes=j(n,1,1)||datat[,1:(ncol(datat)-2)];
  bcpvec=inv(bcpdes`*bcpdes)*bcpdes`*datat[,(ncol(datat)-1)];
  ypred=bcpdes*bcpvec;
  ssr=(datat[,(ncol(datat)-1)]-ypred)##2;ssr=ssr[+,];
  tempmn=datat[,(ncol(datat)-1)];tempmn=tempmn[+,]/n;
  sst=(datat[,(ncol(datat)-1)]-tempmn)##2;sst=sst[+,];
  msr=ssr/(n-ncol(bcpdes));
  rsqfull=1-ssr/sst;
  rfull=sqrt(rsqfull);
  df1=ncol(bcpdes)-1;df2=n-ncol(bcpdes);
  Ffull=(df2*rsqfull)/(df1*(1-rsqfull));
  pfull=1-probf(Ffull,df1,df2);
  sebcpmat=msr*inv(bcpdes`*bcpdes);
  sebcp=sqrt(vecdiag(sebcpmat));

  bresmat=j(mpairs,7,0);dresmat=j(mpairs,7,0);indres=j((mpairs+1),1,0);
  indres=j(Mpairs+1+(serial=1),1,0);
  if (&normal=1) then;do;
    normres=j(mpairs,4,0);
  end;

  %cdfinvt (p=temp,df=df2);
  tcritb=toutput;tcritcp=toutput;tcritd=toutput;

  cppath=bcpvec[1,1];
  secppath=sebcp[1,1];
  tcppath=cppath/secppath;
  pcppath=2*(1-probt(abs(tcppath),df2));
  lcicp=cppath-tcritcp*secppath;
  ucicp=cppath+tcritcp*secppath;
  cpresmat=cppath||secppath||tcppath||df2||pcppath||lcicp||ucicp;

  lcii=floor((1-.01*conf)/2*samples);
  ucii=floor((1-((1-.01*conf)/2))*samples)+1;
  if ((lcii < 1) | (ucii > samples)) then; do;runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;end;
  
  if (mc = 1) then;do;
    mcsamps=samples;
    randsamp=sqrt(-2*log(ranuni(j(mcsamps,mpairs,&seed))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
	mcres=j(mpairs+1,4,0);
	mccorr=j(mpairs,mpairs,1);
	do i = 1 to mpairs;
	  mccorr[i,i]=sebcpmat[(2*i),(2*i)];
	  if ((mpairs > 1) & (i ^= mpairs)) then;do;
	    do j=(i+1) to mpairs;
		  mccorr[i,j]=sebcpmat[(2*i),(2*j)];
		  mccorr[j,i]=sebcpmat[(2*i),(2*j)];
		end;
	  end;
	end;
	rndnb=randsamp*root(mccorr);
    rndna=sqrt(-2*log(ranuni(j(mcsamps,mpairs))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
    mcsave=j(samples,(3*mpairs+1),0);
	mcsave2=j(samples,mpairs,0);
  end;

  do i = 1 to mpairs;
    bpath=bcpvec[(2*i),1];sebpath=sebcp[(2*i),1];
	tbpath=bpath/sebpath;
	pbpath=2*(1-probt(abs(tbpath),df2));
	lcib=bpath-tcritb*sebpath;
	ucib=bpath+tcritb*sebpath;
	bresmat[i,]=bpath||sebpath||tbpath||df2||pbpath||lcib||ucib;
	dpath=bcpvec[((2*i)+1),1];
	sedpath=sebcp[((2*i)+1),1];
	tdpath=dpath/sedpath;
	pdpath=2*(1-probt(abs(tdpath),df2));
	lcid=dpath-tcritd*sedpath;
	ucid=dpath+tcritd*sedpath;
	dresmat[i,]=dpath||sedpath||tdpath||df2||pdpath||lcid||ucid;
	indirect=aresmat[i,1]*bresmat[i,1];
	indres[i,1]=indirect;
	if (&normal = 1) then;do;
      sobseab=sqrt(((aresmat[i,1]##2)*(bresmat[i,2]##2))+((bresmat[i,1]##2)*(aresmat[i,2]##2)));
	  sobelz=indirect/sobseab;
	  sobelp=2*(probnorm(-abs(sobelz)));
	  normres[i,]=indirect||sobseab||sobelz||sobelp;
	end;

	if (mc = 1) then;do;
      asamp=rndna[,i]*aresmat[i,2]+aresmat[i,1];
	  bsamp=rndnb[,i]+bresmat[i,1];
	  absamp=asamp#bsamp;
      mcgrad=rank(absamp);
	  mcsort=absamp;
	  mcsort[mcgrad]=absamp;
	  mcsave[,(3*i-2):(3*i)]=asamp||bsamp||absamp;
	  mcsave2[,i]=absamp;
	  mcllci=mcsort[lcii,1];
	  mculci=mcsort[ucii,1];
      tempmn=mcsort[+,]/mcsamps;
      tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	  mcres[i,]=indirect||semc||mcllci||mculci;
	end;
  end;

  if (serial = 1) then;do;
    indres[mpairs+1,1]=aresmat[1,1]*serres[2,1]*bresmat[2,1];
	if (&normal = 1) then;do;
      indirect=aresmat[1,1]*serres[2,1]*bresmat[2,1];
	  sobseab=sqrt(((aresmat[1,1]##2)*(serres[2,1]##2)*(bresmat[2,2]##2))+((aresmat[1,1]##2)*(bresmat[2,1]##2)*(serres[2,2]##2))+((serres[2,1]##2)*(bresmat[2,1]##2)*(aresmat[2,1]##2)));
      sobelZ=indirect/sobseab;
	  sobelp=2*(probnorm(-abs(sobelz)));
	  serind=indirect||sobseab||sobelZ||sobelp;
	  normres=normres//serind;
	end;
  end;

  if (mc = 1) then;do;
    mcsave[,3*mpairs+1]=mcsave2[,+];
	mcsort=mcsave[,3*mpairs+1];
    mcgrad=rank(mcsort);
    mcsort2=mcsort;
	mcsort2[mcgrad]=mcsort;
	mcsort=mcsort2;
	mcllci=mcsort[lcii];mculci=mcsort[ucii];
    tempmn=mcsort[+,]/mcsamps;
    tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	mcres[mpairs+1,]=indres[+,]||semc||mcllci||mculci;
	if ((&contrast=1) & (mpairs > 1)) then;do;
      npairs = Mpairs*(Mpairs-1)/2; 
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  contsort=contsamp;
	  counter=1;
	  do i = 1 to mpairs-1;
	    do j = (i+1) to mpairs;
		  contsamp[,counter]=mcsave2[,i]-mcsave2[,j];
		  contres[counter,1]=indres[i,1]-indres[j,1];
		  tttt=contsamp[,counter];
          tempmn=tttt[+,]/mcsamps;
          tempsm=(tttt[,1]-tempmn)##2;
          contres[counter,2]=sqrt(tempsm[+,]/(mcsamps-1));
          contgrad=rank(tttt);
		  contsort[contgrad,counter]=tttt;
          contres[counter,3]=contsort[lcii,counter];
		  contres[counter,4]=contsort[ucii,counter];
		  counter=counter+1;
		end;
	  end;
	end;
  end;

  if (mc ^= 1) then;do;
  	badboot = 0;
	detcheck = j((mpairs-1)*(serial=1)+1,1,-999);
	detsum = detcheck[+,];
    bootsamp=j(samples,mpairs+1+(serial=1),0);
	bootsave=j(samples,3*Mpairs+3+2*(serial=1),0);
	indtemp=j(samples,mpairs+(serial=1),0);
	do i = 1 to samples;
		counter1 = 0;
		do until (detsum=0);
		counter1 = counter1+1;
	    sortvar=floor((ranuni(j(n,1,&seed)))*n)+1;
        bootdat=datat[sortvar,];
	    do j = 1 to mpairs;
          tempmn=bootdat[,2*j];tempmn=tempmn[+,]/n;
	      bootdat[,2*j]=bootdat[,2*j]-tempmn;
	    end;
	    bootdes=j(n,1,1)||bootdat[,1:(ncol(bootdat)-2)];
		testi = det(bootdes`*bootdes);
	    detcheck[1,1]=(testi=0);
		if (serial=1) then; do;
			do j = 2 to mpairs;
				bootadat=bootdes[,1:(2*j-1)];
				testj = det(bootadat`*bootadat);
				detcheck[j,1]=(testj=0);
			end;
		end;
		detsum=detcheck[+,];
		badboot = badboot+(counter1=2);
		end;
	  bootbeta=inv(bootdes`*bootdes)*bootdes`*bootdat[,ncol(bootdat)-1];
	  do j = 1 to mpairs;
        boota=inv(ghostdes`*ghostdes)*ghostdes`*bootdat[,(2*j-1)];
	    bootb=bootbeta[2*j,1];
        if ((serial=1) & (j > 1)) then;do;
		  bootadat=bootdes[,1:(2*j-1)];
		  bootserb=inv(bootadat`*bootadat)*bootadat`*bootdes[,2*j];
		  boota=bootserb[1,1];
		  bootd=bootserb[2,1];
		  bootsamp[i,(j+1)]=bootsave[i,1]*bootd*bootb;
		  bootsave[i,(3*j+2)]=bootsave[i,1]*bootd*bootb;
		  bootsave[i,(3*j+1)]=bootd;
		  indtemp[i,(j+1)]=bootsave[i,1]*bootd*bootb;
	    end;
	    bootsamp[i,j]=bootb*boota;
        bootsave[i,(3*j-2):(3*j)]=boota||bootb||boota*bootb;
		indtemp[i,j]=boota*bootb;
	  end;
	  bootsave[i,(ncol(bootsave)-1)]=bootbeta[1,1];
	  tempsm=indtemp[i,];
	  bootsave[i,ncol(bootsave)]=tempsm[,+]+bootbeta[1,1];
    end;

	if (badboot>0)then; do;
		runnotes[14,1] = 14;
	end;

    if ((&contrast = 1) & (mpairs > 1)) then;do;
      npairs = ncol(indtemp)*(ncol(indtemp)-1)/2;
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  counter=1;
	  do i = 1 to ncol(indtemp)-1;
	    do j = i+1 to ncol(indtemp);
		contsamp[,counter]=indtemp[,i]-indtemp[,j];
		contres[counter,1]=indres[i,1]-indres[j,1];
		counter=counter+1;
		end;
	  end;
	end;
	tempsm=bootsamp[,1:(ncol(bootsamp)-1)];
    bootsamp[,ncol(bootsamp)]=tempsm[,+];
	bootsave[,(ncol(bootsave)-2)]=tempsm[,+];
	indres[nrow(indres),1]=indres[+,];
	bootsort=bootsamp;
	seboots=j(mpairs+1+(serial=1),1,0);
	bccires=j(4,mpairs+1+(serial=1),0);
	bootllci=j(1,ncol(bootsamp),0);
	bootulci=j(1,ncol(bootsamp),0);
    zalpha2=sqrt(-2*log(alpha/2));
    zalpha2=(zalpha2+((((zalpha2*p4+p3)*zalpha2+p2)*zalpha2+p1)*zalpha2+p0)/((((zalpha2*q4+q3)*zalpha2+q2)*zalpha2+q1)*zalpha2+q0));
    do i = 1 to ncol(bootsamp); *3;
	  tttt=bootsamp[,i];
      bootgrad=rank(tttt);
      bootsort[bootgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;
      seboots[i,1]=sqrt(tempsm[+,]/(samples-1));
	  bootsam2=indres[i,1]//bootsamp[,i];
      bootgra2=rank(bootsam2);
	  if (bc=1) then;do;
	    ttttt=bootsamp[,i];
        tttt=(ttttt < indres[i,1]);bccires[1,i]=tttt[+,]/samples;
        bccires[2,i]=bccires[1,i];
        if (bccires[1,i] > .5) then;do;bccires[2,i]=1-bccires[1,i];end;
		bccires[3,i]=sqrt(-2*log(bccires[2,i]));
		tttt=bccires[3,i];
        bccires[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccires[1,i] <= .5) then;do;
		  bccires[4,i]=-bccires[4,i];
		end;
        bcllii=probnorm(2*bccires[4,i]-zalpha2)*samples;
		bcucii=probnorm(2*bccires[4,i]+zalpha2)*samples;
		lcii=round(bcllii);
		ucii=floor(bcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
		  runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;
		end;
		bootllci[1,i]=bootsort[lcii,i];
		bootulci[1,i]=bootsort[ucii,i];
	  end;
	end;
	if (bc ^= 1) then;do;
      bootllci=bootsort[lcii,];
	  bootulci=bootsort[ucii,];
	end;
	bootci=bootllci`||bootulci`;
	bootres=indres||seboots||bootci;
  end; 
  if ((&contrast = 1) & (mpairs > 1)) then;do; *2;
    bccicont=j(4,ncol(contsamp),0);
	contsort=contsamp;
	contllci=j(1,ncol(contsamp),0);
	contulci=j(1,ncol(contsamp),0);
    do i = 1 to ncol(contsamp);
      tttt=contsamp[,i];
      contgrad=rank(tttt);
      contsort[contgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;contres[i,2]=sqrt(tempsm[+,]/(samples-1));
	  contsam2=contres[i,1]//contsamp[,i];
	  contgra2=rank(contsam2);
	  if (bc=1) then;do;

	    ttttt=contsamp[,i];
        tttt=(ttttt < contres[i,1]);bccicont[1,i]=tttt[+,]/samples;
        bccicont[2,i]=bccicont[1,i];
		if (bccicont[1,i] > .5) then;do;bccicont[2,i]=1-bccicont[1,i];end;
		bccicont[3,i]=sqrt(-2*log(bccicont[2,i]));
	    tttt=bccicont[3,i];
        bccicont[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccicont[1,i] <= 0.5) then;do;bccicont[4,i]=-bccicont[4,i];end;
        cbcllii=probnorm(2*bccicont[4,i]-zalpha2)*samples;
		cbcucii=probnorm(2*bccicont[4,i]+zalpha2)*samples;
		lcii=round(cbcllii);
		ucii=floor(cbcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
          runnotes[4,1]=4;lcii=1;ucii=samples;
		end;
		contllci[1,i]=contsort[lcii,i];
		contulci[1,i]=contsort[ucii,i];
	  end;
	end; 
    if (bc ^= 1) then;do;
	  contllci=contsort[lcii,];
	  contulci=contsort[ucii,];
	end;
	contci=contllci`||contulci`;
	contres[,3:4]=contci;
  end; *2;
end; *1; 

print "************************ MEMORE Procedure for SAS Version 1.1 *************************";
print "Written by Amanda K. Montoya and Andrew F. Hayes";
print "Documentation available at afhayes.com";
print "****************************************************************************************";
if (criterr = 0) then;do; 
  varrlabs={"Y = " "M1 = " "M2 = " "M3 = " "M4 = " "M5 = " "M5 = " "M5 = " "M6 = " "M7 = " "M8 = " "M9 = " "M10 = "};
  if (mpairs=1) then;do;
    varrlabs={"Y = " "M = "};
  end;
  tttt=ynames//mnamemat;
  print tttt [label = "Variables:" rowname=varrlabs];  
  compname=" "||ynames[1,1]||" - "||ynames[1,2]||" "||" "||" ";
  do j = 1 to mpairs;
    tttt=" "||mnamemat[j,1]||" - "||mnamemat[j,2]||" "||" "||" ";
    compname=compname//tttt;
  end;
  do j = 1 to mpairs;
	tttt="("||mnamemat[j,1]||" + "||mnamemat[j,2]||")"||"/2"||"centered";
	compname=compname//tttt;
  end;
  temp1={"M1diff = " "M2diff = " "M3diff = " "M4diff = " "M5diff = " "M6diff = " "M7diff = " "M8diff = " "M9diff = " "M10diff = "};
  temp2={"M1avg = " "M2avg = " "M3avg = " "M4avg = " "M5avg = " "M6avg = " "M7avg = " "M8avg = " "M9avg = " "M10avg = "};
  temprnam={"Ydiff = " "Mdiff = " "Mavg = "};
  if (mpairs ^= 1) then;do;
    temprnam="Ydiff = "||temp1[1,1:mpairs]||temp2[1,1:mpairs];
  end;
  print compname [label="Computed Variables:" rowname=temprnam];
  print n [label="Sample Size:"];
  if (&seed ^= 0) then;do;
    seedt=&seed;
	print seedt [label = "Custom seed:"];
  end;
  print "****************************************************************************************";
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
  rowlab="'X'";
  print cresmat [label = "Model" rowname=rowlab colname = collab format=&decimals];
  print "****************************************************************************************";
  alabs = {"a1" "a2" "a3" "a4" "a5" "a6" "a7" "a8" "a9" "a10"};
  do j = 1 to Mpairs;
    if ((j > 1) & (serial = 1)) then;do;goto stpit;end;
    if (mpairs=1) then;do;
       mlab="Mdiff = "||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	if (mpairs > 1) then;do;
       mlab=temp1[1,j]||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	rowlab="'X'";
	aresmtmp=aresmat[j,];
    print aresmtmp [label = "Model" rowname = rowlab colname=collab format=&decimals];
	print "****************************************************************************************";
  end;
  stpit:
  if (serial = 1) then;do;
    mlab="M2diff = "||mnamemat[2,1]||" - "||mnamemat[2,2];
    print mlab [label="Outcome:"];
	clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
	print m2modsum [label = "Model Summary" colname=clab format=&decimals];
	m2labs="'X'"||"M1diff"||"M2diff";
    print serres [label = "Model" rowname = m2labs colname=collab format = &decimals];
    print "****************************************************************************************";
  end;
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  modsumr=Rfull||Rsqfull||MSR||Ffull||df1||df2||pfull;
  clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
    collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
  print modsumr [label="Model Summary" colname=clab format = &decimals];
  modres=cpresmat//bresmat//dresmat;
  bdlabs = {"M1diff" "M2diff" "M3diff" "M4diff" "M5diff" "M6diff" "M7diff" "M8diff" "M9diff" "M10diff"};
  bslabs = {"M1avg" "M2avg" "M3avg" "M4avg" "M5avg" "M6avg" "M7avg" "M8avg" "M9avg" "M10avg"};
  modlabs="'X'"||"Mdiff"||"Mavg";
  if (mpairs ^= 1) then;do;
    modlabs = "'X'"||bdlabs[1,1:mpairs]||bslabs[1,1:mpairs];
  end;
  print modres [label = "Model" rowname = modlabs colname=collab format = &decimals];
 print "*********************** TOTAL, DIRECT, AND INDIRECT EFFECTS *****************************";
   collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
 rwnme=" ";
 print cresmat [label = "Total effect of X on Y" colname=collab rowname = rwnme format = &decimals];
 print cpresmat [label = "Direct effect of X on Y" colname=collab rowname = rwnme format = &decimals];
 if (mc = 1) then;do;
   indlabs = {"Effect" "MCSE" "MC LLCI" "MC ULCI"};
   indres=mcres;
 end;
 if (mc ^= 1) then;do;
   indlabs = {"Effect" "Boot SE" "BootLLCI" "BootULCI"};
   indres=bootres;
 end;
 mlab = {"Ind1" "Ind2" "Ind3" "Ind4" "Ind5" "Ind6" "Ind7" "Ind8" "Ind9" "Ind19"};
 m2lab=mlab[1,1:(nrow(indres)-1)]||"Total";
 if (mpairs = 1) then;do;
   indres=indres[1,];
 end;
 print indres [label="Indirect Effect of X on Y through M" rowname=m2lab colname=indlabs format = &decimals];
 if (&normal = 1) then;do;
   clab={"Effect" "SE" "Z" "p"};
   print normres [label = "Normal Theory Test for Indirect Effect" rowname=mlab colname=clab format=&decimals];
 end;

 indkey=j((ncol(m2lab)-1),7,"        ");
 do i = 1 to (ncol(m2lab)-1);
   indkey[i,]="X"||"->"||bdlabs[1,i]||"->"||"Ydiff"||" "||" ";
 end;
 if (serial = 1) then;do;
   indkey[3,]="X"||"->"||bdlabs[1,1]||"->"||bdlabs[1,2]||"->"||"Ydiff";
 end;
 print indkey [label = "Indirect effect key" rowname=mlab];
 if ((&contrast=1) & (mpairs > 1)) then;do;
  contlab="(C1)"//"(C2)"//"(C3)"//"(C4)"//"(C5)"//"(C6)"//"(C7)"//"(C8)"//"(C9)"//"(C10)";
  contlab=contlab//"(C11)"//"(C12)"//"(C13)"//"(C14)"//"(C15)"//"(C16)"//"(C17)"//"(C18)"//"(C19)"//"(C20)";
  contlab=contlab//"(C21)"//"(C22)"//"(C23)"//"(C24)"//"(C25)"//"(C26)"//"(C27)"//"(C28)"//"(C29)"//"(C30)";
  contlab=contlab//"(C31)"//"(C32)"//"(C33)"//"(C34)"//"(C35)"//"(C36)"//"(C37)"//"(C38)"//"(C39)"//"(C40)";
  contlab=contlab//"(C41)"//"(C42)"//"(C43)"//"(C44)"//"(C45)";
  print contres [label="Pairwise Contrasts Between Specific Indirect Effects" rowname=contlab colname=indlabs format=&decimals];
  contkey = " "||" "||" ";
  do i = 1 to mpairs-1;
    do j = i+1 to mpairs;
	  tttt=mlab[1,i]||" - "|| mlab[1,j];
	  contkey=contkey//tttt;
	end;
  end;
  contkey=contkey[2:nrow(contkey),];
  print contkey [label = "Contrast definitions:" rowname = contlab];
 end;
end; 
print "*************************** ANALYSIS NOTES AND WARNINGS ******************************";
print "Check SAS log for errors.  Do not interpret output if errors are found.";
do i = 1 to nrow(runnotes);
  if (runnotes[i,1]=1) then;do;
    print missing [label="NOTE: Somecases were deleted due to missing data.  The number of cases was:"];
  end;
  if (runnotes[i,1]=2) then;do;
    print "ERROR: Exactly two Y variables must be provided in the Y= list.";
  end;
  if (runnotes[i,1]=3) then;do;
    print samples [label="NOTE: An invalid number of samples was specified.  The number of samples used was:"];
  end;
  if (runnotes[i,1]=4) then;do;
    print "ERROR: The number of samples specified is insufficient for desired confidence.";
	print "Please increase the number of samples or decrease confidence.";
	tttt=conf||samples;
	print tttt [label="Confidence and samples specified:"];
  end;
  if (runnotes[i,1]=5) then;do;
    print "NOTE: The confidence specified was not between 50 and 99.99.  Level of confidence";
	print "was adjusted to 95%:";
  end;
  if (runnotes[i,1]=6) then;do;
    print "ERROR: An even number of variables is required in the M= list.";
  end;
  if (runnotes[i,1]=7) then;do;
    print copyname [label = "ERROR: Two of the specified variables are copies.  The variable names are:"];
  end;
  if (runnotes[i,1]=8) then;do;
    print "ERROR: All specified variables must be unique. No variables may be the same in M and Y.";
  end;
  if (runnotes[i,1]=9) then;do;
    print "NOTE: Both Monte Carlo and bootstrap methods were requested.  Only Monte Carlo CI is provided.";
  end;
  if (runnotes[i,1]=10) then;do;
    print "NOTE: Contrast cannot be constructed with only one pair of mediators.";
  end;
  if (runnotes[i,1]=12) then;do;
    print "NOTE: Monte Carlo confidence intervals are not available for serial mediation";
  end;
  if (runnotes[i,1]=13) then;do;
    print "NOTE: The serial mediation model must have two pairs of mediators.";
  end;
  if (runnotes[i,1]=14) then;do;
    print badboot [label = "NOTE: Some bootstrap samples had to be replaced. The number of such replacements was:"];
  end;
end;

if (criterr=0) then;do;
  if ((mc ^= 1) & (bc = 1)) then;do;
    print "Bootstrap confidence interval method: Bias corrected";
  end;
  if ((mc ^= 1) & (bc ^= 1)) then;do;
    print "Bootstrap confidence interval method: Percentile";
  end;
  if (mc = 1) then;do;
    print samples [label="Number of samples for Monte Carlo confidence intervals:"];
  end;
  if (mc ^= 1) then;do;
    print samples [label="Number of samples for bootstrap confidence intervals:"];
  end;
  print conf [label = "Level of confidence for all confidence intervals in output:"];
  
  blabs="b1"||"b2"||"b3"||"b4"||"b5"||"b6"||"b7"||"b8"||"b9"||"b10";
  savelab=j(1,3*Mpairs,"    ");
  do i=1 to mpairs;
    savelab[1,3*i]=mlab[1,i];
    if (mpairs = 1) then;do;
      savelab[1,3*i-1]="b";
	  savelab[i,3*i-2]="a";
    end;
    if (mpairs ^= 1) then;do;
	  savelab[1,3*i-1]=blabs[1,i];
	  savelab[1,3*i-2]=alabs[1,i];
    end;
  end;
  if ((savboot=1) & (mc = 1)) then;do;
    savelab=savelab||"TotalInd";
    create &save from mcsave [colname=savelab];
    append from mcsave;
  end;
  if ((savboot=1) & (mc ^= 1)) then;do;
	if ((serial = 1) & (mpairs > 1)) then;do;
      savelab=savelab||"a3"||"Ind3";
    end;
    savelab=savelab||"TotalInd"||"c'"||"c";
    create &save from bootsave [colname=savelab];
    append from bootsave;
  end;
end;
quit;
%mend;
